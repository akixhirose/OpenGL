//===================================================================
// 行列/ベクトル演算ライブラリ
//===================================================================
#include <math.h>
#include "matrix.h"

//-------------------------------------------------------------------
// 単位行列生成
//-------------------------------------------------------------------
void MatrixIdentity(MATRIX m)
{
	int i, j;

	for (i = 0; i < 4; i++) {
		for (j = 0; j < 4; j++) {
			m[i][j] = (float)(i == j);
		}
	}
}

//-------------------------------------------------------------------
// 平行移動行列生成
//-------------------------------------------------------------------
void MatrixTranslation(MATRIX m, float fX, float fY, float fZ)
{
	MatrixIdentity(m);
	m[3][0] = fX;
	m[3][1] = fY;
	m[3][2] = fZ;
}

//-------------------------------------------------------------------
// 拡大縮小行列生成
//-------------------------------------------------------------------
void MatrixScaling(MATRIX m, float fSx, float fSy, float fSz)
{
	MatrixIdentity(m);
	m[0][0] = fSx;
	m[1][1] = fSy;
	m[2][2] = fSz;
}

//-------------------------------------------------------------------
// X軸回転行列生成
//-------------------------------------------------------------------
void MatrixRotationX(MATRIX m, float fPitch)
{
	MatrixIdentity(m);
	m[1][1] = m[2][2] = cosf(fPitch);
	m[1][2] = sinf(fPitch);
	m[2][1] = -m[1][2];
}

//-------------------------------------------------------------------
// Y軸回転行列生成
//-------------------------------------------------------------------
void MatrixRotationY(MATRIX m, float fYaw)
{
	MatrixIdentity(m);
	m[0][0] = m[2][2] = cosf(fYaw);
	m[2][0] = sinf(fYaw);
	m[0][2] = -m[2][0];
}

//-------------------------------------------------------------------
// Z軸回転行列生成
//-------------------------------------------------------------------
void MatrixRotationZ(MATRIX m, float fRoll)
{
	MatrixIdentity(m);
	m[0][0] = m[1][1] = cosf(fRoll);
	m[0][1] = sinf(fRoll);
	m[1][0] = -m[0][1];
}

//-------------------------------------------------------------------
// YXZ軸回転
//-------------------------------------------------------------------
void MatrixRotationYawPitchRoll(MATRIX m, float fYaw, float fPitch, float fRoll)
{
	MATRIX mX, mY, mZ;
	MatrixRotationX(mX, fPitch);
	MatrixRotationY(mY, fYaw);
	MatrixRotationZ(mZ, fRoll);
	MatrixMultiply(m, mZ, mX);
	MatrixMultiply(m, m, mY);
}

//-------------------------------------------------------------------
// 任意軸周りの回転
//-------------------------------------------------------------------
void MatrixRotationAxis(MATRIX m, VECTOR3 v, float fAngle)
{
	float s = sinf(fAngle);
	float c = cosf(fAngle);
	float d = 1.0f - c;
	float& x = v[0];
	float& y = v[1];
	float& z = v[2];
	m[0][0] = c + d * x * x;
	m[0][1] = d * x * y + s * z;
	m[0][2] = d * x * z - s * y;
	m[0][3] = 0.0f;
	m[1][0] = d * x * y - s * z;
	m[1][1] = c + d * y * y;
	m[1][2] = d * y * z + s * x;
	m[1][3] = 0.0f;
	m[2][0] = d * x * z + s * y;
	m[2][1] = d * y * z - s * x;
	m[2][2] = c + d * z * z;
	m[2][3] = 0.0f;
	m[3][0] = 0.0f;
	m[3][1] = 0.0f;
	m[3][2] = 0.0f;
	m[3][3] = 1.0f;
}

// 行列×行列 (結果の行列に元の行列指定不可)
static void _MatrixMultiply(MATRIX m, MATRIX mL, MATRIX mR)
{
	int i, j, k;

	for (i = 0; i < 4; i++) {
		for (j = 0; j < 4; j++) {
			m[i][j] = 0.0f;
			for (k = 0; k < 4; k++) {
				m[i][j] += mL[k][j] * mR[i][k];
			}
		}
	}
}

//-------------------------------------------------------------------
// 行列×行列
//-------------------------------------------------------------------
void MatrixMultiply(MATRIX m, MATRIX mL, MATRIX mR)
{
	if (m == mL || m == mR) {
		// 代入先の変数と同じものを計算に使用
		MATRIX mW;
		int i, j;

		_MatrixMultiply(mW, mL, mR);
		for (i = 0; i < 4; i++) {
			for (j = 0; j < 4; j++) {
				m[i][j] = mW[i][j];
			}
		}
	} else {
		// 計算値と結果は異なる変数
		_MatrixMultiply(m, mL, mR);
	}
}

// 行列×ベクトル (結果のベクトルに元のベクトル指定不可)
static void _Vec3TransformCoord(VECTOR3 v, MATRIX m, VECTOR3 vR)
{
	int i, j;

	for (i = 0; i < 3; i++) {
		v[i] = 0.0f;
		for (j = 0; j < 3; j++) {
			v[i] += m[j][i] * vR[j];
		}
		v[i] += m[j][i];
	}
}

//-------------------------------------------------------------------
// 行列×ベクトル
//-------------------------------------------------------------------
void Vec3TransformCoord(VECTOR3 v, MATRIX m, VECTOR3 vR)
{
	if (v == vR) {
		VECTOR3 vW;
		int i;

		_Vec3TransformCoord(vW, m, vR);
		for (i = 0; i < 3; i++) {
			v[i] = vW[i];
		}
	} else {
		_Vec3TransformCoord(v, m, vR);
	}
}

// 行列×ベクトル(移動無し) (結果のベクトルに元のベクトル指定不可)
static void _Vec3TransformNormal(VECTOR3 v, MATRIX m, VECTOR3 vR)
{
	int i, j;

	for (i = 0; i < 3; i++) {
		v[i] = 0.0f;
		for (j = 0; j < 3; j++) {
			v[i] += m[j][i] * vR[j];
		}
	}
}

//-------------------------------------------------------------------
// 行列×ベクトル(移動無し)
//-------------------------------------------------------------------
void Vec3TransformNormal(VECTOR3 v, MATRIX m, VECTOR3 vR)
{
	if (v == vR) {
		VECTOR3 vW;
		int i;

		_Vec3TransformNormal(vW, m, vR);
		for (i = 0; i < 3; i++) {
			v[i] = vW[i];
		}
	} else {
		_Vec3TransformNormal(v, m, vR);
	}
}

// ベクトルの外積 (結果のベクトルに元のベクトル指定不可)
static void _Vec3Cross(VECTOR3 v, VECTOR3 vL, VECTOR3 vR)
{
	v[0] = vL[1] * vR[2] - vL[2] * vR[1];
	v[1] = vL[2] * vR[0] - vL[0] * vR[2];
	v[2] = vL[0] * vR[1] - vL[1] * vR[0];
}

//-------------------------------------------------------------------
// ベクトルの外積
//-------------------------------------------------------------------
void Vec3Cross(VECTOR3 v, VECTOR3 vL, VECTOR3 vR)
{
	if (v == vL || v == vR) {
		VECTOR3 vW;
		int i;

		_Vec3Cross(vW, vL, vR);
		for (i = 0; i < 3; i++) {
			v[i] = vW[i];
		}
	} else {
		_Vec3Cross(v, vL, vR);
	}
}

//-------------------------------------------------------------------
// ベクトルの内積
//-------------------------------------------------------------------
float Vec3Dot(VECTOR3 vL, VECTOR3 vR)
{
	return vL[0] * vR[0] + vL[1] * vR[1] + vL[2] * vR[2];
}

//-------------------------------------------------------------------
// ベクトルの正規化
//-------------------------------------------------------------------
void Vec3Normalize(VECTOR3 v, VECTOR3 vR)
{
	float f = 1.0f / Vec3Length(vR);
	v[0] = vR[0] * f;
	v[1] = vR[1] * f;
	v[2] = vR[2] * f;
}

//-------------------------------------------------------------------
// ベクトル長の2乗の取得
//-------------------------------------------------------------------
float Vec3LengthSq(VECTOR3 v)
{
	return v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
}

//-------------------------------------------------------------------
// ベクトル長の取得
//-------------------------------------------------------------------
float Vec3Length(VECTOR3 v)
{
	return sqrtf(Vec3LengthSq(v));
}

//-------------------------------------------------------------------
// ベクトル＋ベクトル
//-------------------------------------------------------------------
void Vec3Add(VECTOR3 v, VECTOR3 vL, VECTOR3 vR)
{
	v[0] = vL[0] + vR[0];
	v[1] = vL[1] + vR[1];
	v[2] = vL[2] + vR[2];
}

//-------------------------------------------------------------------
// ベクトル−ベクトル
//-------------------------------------------------------------------
void Vec3Subtract(VECTOR3 v, VECTOR3 vL, VECTOR3 vR)
{
	v[0] = vL[0] - vR[0];
	v[1] = vL[1] - vR[1];
	v[2] = vL[2] - vR[2];
}

//-------------------------------------------------------------------
// ベクトル×スカラー
//-------------------------------------------------------------------
void Vec3Scale(VECTOR3 v, VECTOR3 vL, float fS)
{
	v[0] = vL[0] * fS;
	v[1] = vL[1] * fS;
	v[2] = vL[2] * fS;
}

//===================================================================
// eof
//===================================================================